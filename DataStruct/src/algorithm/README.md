# 算法

概念：解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。

算法：操作数据和解决问题的办法

算法的基本特性：

1) 输入和输出：

   返回值、打印

   可以没有输入，不能没有输出
2) 有穷性：指在有限的步骤内执行完成，不会无限循环
3) 结果的确定性：指输出结果唯一，每一步都有确定的含义
4) （代码的）可行性：解决问题的思维，可以用代码编写出来

算法设计的要求：

1. 正确性
2. 可读性：后期翻看和维护
3. 健壮性：入参合理，边界条件
4. 时间效率和存储效率

效率分析

> 1.最差的执行情况
>
> 2.假设每行语句执行时间一样

专业术语：时间复杂度，空间复杂度

时间复杂度：一个算法的执行，随数据规模增大，而增加的时间成本

相关：渐进下界，渐进上界，渐进紧界

相关：判断数组中两数是否能组成目标值，大数加法，递归，杨辉三角

## 排序

类型：数组排序，链表排序

种类：冒泡排序、选择排序、插入排序、归并排序、快速排序、希尔排序、堆排序、计数排序、桶排序、基数排序

## 范围内找数

种类：水仙花数，质数

## 数组

种类：合并两个数组，

指针：快慢指针，对撞指针

## 链表

## 线性表

种类：二分枚举，双指针，前缀和，

## 递归

练习题：

1) 阶乘
2) 倒序输出正整数

## 注意问题：

1.(int+int)/2 可能会溢出，解决方法：使用无符号右移 (int+int) >>>1

2.比较时，小的数放左边，大的数放右边 while(i<j)

## 技巧：

1. 7/2 保留整数部分 可以采用无符号右移 7>>>1

哈希算法与洪水攻击

哈希：把任意长度的输入 通过算法 变换成固定长度的输出

思想：空间换时间

## 哈希函数：

> 1.直接寻址法：（尾号）一一对应。取关键字或关键字的线性函数 作为散列地址
>
> 2.除留取余法：取模映射。对关键字或关键字的部分取模 作为散列地址。
> 取模的除数一般为素数/质数
> 3.取随机数法：直接使用随机函数，取关键字的随机值 作为散列地址。
>
> 4.数字分析法：根据数字的特性，经过分析，取部分进行计算（如手机后四位，身份证后四位等）
>
> 5.平方取中法：当数字没有规律，先求平方，取中间几位作为散列地址
>
> 6.折叠法：取关键字的几部分 取叠加和 作为散列地址。

hash碰撞：不同的key映射到同一个地址

发生散列冲突的原因 - 抽屉原理

解决冲突的办法：再找一个空闲位置 具体如下：

1) 线性探测：1号柜子如果满了，顺延到下一个位置-2号柜子
2) 二次探测：如果满了，按照一定规律顺延，如以二次方顺延 value value+1^2 value+2^2
3) 双重哈希：使用两种哈希函数，第一个位置被占用时，计算第二个
4) 链表法：让一个位置 存储多个value（用链表串联起来）

## 树

介绍：

1) 递归的数据结构，由根节点和它的孩子，以及孩子的孩子等等组成。
2) 其中没有节点的节点 叫做叶子节点.如EFCG。
3) 节点的度：指拥有的子节点个数，A的度是3，B的度是2，D的度是1。
4) 节点的关系：子节点是父节点的孩子节点，父节点也是子节点的双亲结点。有相同父节点的节点叫兄弟节点。A是B的双亲结点，B是A的孩子节点，B和C是兄弟节点。
5) 输的层次：A在第一层，BCD在第二层，EFG在第三层
6) 树的深度：是最大层次数，即为3.
   ![](C:/Users/Administrator/图片/知识文件夹/学/数据结构与算法/树.png)

种类：二叉树

### 二叉树

![](C:/Users/Administrator/图片/知识文件夹/学/数据结构与算法/二叉树.png)
介绍：

1) 最多分出两个度的树。
2) 左侧叫做左子树，右侧叫做右子树。

分类：满二叉树，斜树，完全二叉树,平衡二叉树（红黑树，AVL树）

1) 满二叉树：所有叶子节点都在同一层，所有分支节点（非叶子结点）都有左右子树

> 1.节点个数是明确的（深度h：i层：2^(i-1),共2^i-1个节点）

2) 斜树：所有的子节点都向一个方向倾斜，只分叉树左子树和右子树。类似单向链表，左斜树，右斜树。
3) 完全二叉树：对于高度/深度为h的二叉树而言，h-1层都是满的，h层节点在左侧连续排列，空位都在右侧。

> 1.满树是完全二叉树，完全二叉树不一定是满树。
> 2.如果将完全二叉树的节点进行编号，对于编号为k的节点：
> 2.1 父节点就是k/2
> 2.2 如果有孩子节点，现有做孩子2k,后有右孩子2k+1
>
![满树](C:/Users/Administrator/图片/知识文件夹/学/数据结构与算法/二叉树-满树.png)
![斜树](C:/Users/Administrator/图片/知识文件夹/学/数据结构与算法/二叉树-斜树.png)

树的遍历：对树中的每一个节点都访问一次，且只访问一次。

1) 深度优先遍历（DFS）

名称：Deep First Search

遍历方式：先序遍历（前序遍历），中序遍历，后序遍历
> 先序遍历：根节点->左子树->右子树：ABC
>
> 中序遍历：左子树->根节点->右子树：BAC
>
> 左子树->右子树->根节点：BCA

2) 广度优先遍历(BFS)

名称：Breath First Search
> 广度优先遍历：A->B->C

### 树的进阶

（-）树的存储结构

1. 双亲表示法 记录每一个节点，及其对应父节点的位置

   数组，节点自身的值，父节点的位置（数组的下标）

   数据域 | 指针域

   data | parent

特点：找双亲容易，找孩子难

2. 改进方案一

   数据域|指针域|孩子指针1|孩子指针n

   data|parent|child1|childn

额外记录添加孩子的指针域，记录每个节点的父节点以及孩子节点的位置

问题：某一个父节点孩子较多，容易造成空间浪费

3. 改进方案二

   数据域|指针域|长子指针

   data|parent|firstChild 问题：不能找到兄弟

4. 改进方案三

   数据域|指针域|下一个兄弟指针

   data|parent|sibling

5. 孩子表示法

   结构：数组+链表

   数组存储节点本身，链表存储的是孩子的指针位置
   ![](C:\Users\Administrator\图片\知识文件夹\学\数据结构与算法\树-孩子表示法.png)

   改进方案二：

   ![](C:\Users\Administrator\图片\知识文件夹\学\数据结构与算法\树-孩子表示法-方案二.png)
6. 孩子兄弟表示法

   节点 | 长子域 | 右侧兄弟域

   data|firstChild|rightsib

   ![](C:\Users\Administrator\图片\知识文件夹\学\数据结构与算法\树-孩子兄弟表示法.png)
   （二）树和二叉树的转化 1.树转化为二叉树

口诀：兄弟相连留长子

三步：加线，抹线，旋转
> 加线：兄弟节点加线
>
> 抹线：除长子外的父子节点抹线
>
> 旋转：顺时针旋转45°

2.森林转化为二叉树

将每棵树转化为二叉树，然后将多颗二叉树整合在一起。将右一颗二叉树作为前一棵二叉树树的右节点连起来

3.二叉树转化为树

三步：旋转，加线，抹线

（三）二叉树的存储结构

1. 满二叉树、完全二叉树

数组存储

2. 非满二叉树

链式存储：

结构别名：二叉链表

左孩子lchild | 数据data | 右孩子rchild

左指针域 | 数据域 | 右指针域

改进方案：

结构别名：三叉链表

右孩子rchild | 数据data | 右孩子lchild | 双亲parent

右指针域 | 数据域 | 右指针域 | 双亲域

（四）线索二叉树

在链式存储结构中，增加前驱和后继节点的信息，这些信息称之为线索。

加上了线索的二叉树，称之为线索二叉树。

线索化：根据遍历方式，增加线索的过程叫做线索化。

所用：增加了前驱和后继，就可以把二叉树看做链表结构，可以像遍历链表那样遍历二叉树。

结构：

左孩子lchild | 左标识域ltag | 数据data | 右标识域rtag | 右孩子rchild

标识代表的是 左右孩子位置 纯纯的是否是线索（前驱 or 后继）

如ltag==0 lchild指向的是节点的左孩子，如果ltag==1 lchild指向的是前驱节点

如rtag==0 rchild指向的是节点的右孩子，如果rtag==1 lchild指向的是后继节点

性质：按照遍历顺序（前序，中序，后序，广度优先），得到的线索不同（中序遍历结果得出的是，中序线索二叉树，前序后序同理）

#### 赫夫曼树

##### 1、认识概念

别名：哈夫曼树

##### 树的长度

##### 输的权重

##### 树的带权路径

<img src="C:\Users\Administrator\图片\知识文件夹\学\数据结构与算法\二叉树-权重.png" style="zoom: 67%;" />

简称：WPL（Weighted Path Length of Tree）

途中的树的带权路径为 3*3+6*3+1*2+4*2+8*2=9+18+2+8+16=53

赫夫曼树的概念：树的带权路径长度最小的二叉树。

<img src="C:\Users\Administrator\图片\知识文件夹\学\数据结构与算法\二叉树-赫夫曼树.png" style="zoom: 80%;" />

##### 2、构造逻辑

借助有序队列，不断从队列中取出最小的两个节点，然后求出节点之和，作为新的节点重新存入队列中，存入时保证队列有序。当队列中只剩余一个值时，构造完成。

构造出来的树的特点，权重大的在上层，权重晓得节点在底层，以保证叶子结点的带权路径长度尽可能的小，最终整棵树的带权路径长度也最小。
![](C:/Users/ADMINI~1/AppData/Local/Temp/Rar$DRa0.047/images/image-20210105164651030.png)
![](C:\Users\Administrator\图片\知识文件夹\学\数据结构与算法\二叉树-赫夫曼树-构造.png)

（六）二叉查找树

名称：二叉查找树/二叉搜索树（Binary Search Tree）BST

如果左子树不为空，则左子树上所有节点的值都小于根节点的值;

如果右子树不为空，则右子树上所有节点的值都大于根节点的值;

操作：搜索，查找和删除

1) 搜索：
2) 查找：插入保证仍然是BST树

> 1.判断是否存在相同节点，如果节点存在，不操作
>
> 2.如果节点不存在，作为一个新的叶子结点插入到合适的位置中

3) 删除

> 1.当要删除的是叶子结点时，直接从父节点上移除
>
> 2.当要删除的节点只有一个子节点时，将子节点链接到当前节点的父节点上。
>
> 3.当要删除的节点有两个节点时，从删除节点的右子树中找到最小值的节点，移到删除节点的位置中，并且原最小值的节点删掉